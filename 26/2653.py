with open('26_2653.txt') as file:
    coins = file.readlines()[1:]  # выкидываем ненужное первое значение (количество монет)

coins = [int(x) for x in coins] # делаем строки числами
coins = sorted(coins)  # сортируем по возрастанию

max_value = sum(coins) # максимальное значение как сумма всех монет
print(max_value)

values = [1] + [0]*max_value # добавляем фиктивное значение 0, которое условно можно получить всегда
for coin in coins:
    last = -values[::-1].index(1) # поиск последней единицы в значениях
    tail = values[:last] # делаем хвост- это всё слева до последней единицы (то что могло собраться до следующей монеты)
    for i, x in enumerate(tail):  # при добавлении монеты надо взять все предыдущите возможности и прибавить к ним варианты с новой монетой
        values[coin+i] += x   # прибавляем каждый элемент из хвоста со сдвигом в новую монету

print(values.count(0)) # сколько значений нельзя собрать из набора монет
print(max_value - values[::-1].index(0)) # максимальное значение, которое нельзя собрать

# плюс такого подхода, что если что-то можно собрать, то значение будет не просто единица, а количество вариантов такого набора